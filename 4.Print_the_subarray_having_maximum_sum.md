# **Print the subarray having maximum sum**
- [Explanation link from TUF](https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/)
## Approach
- Our approach is to store the starting index and the ending index of the subarray. Thus we can easily get the subarray afterward without actually storing the subarray elements.

- If we carefully observe our algorithm, we can notice that the subarray always starts at the particular index where the sum variable is equal to 0, and at the ending index, the sum always crosses the previous maximum sum(i.e. maxi).

- So, we will keep a track of the starting index inside the loop using a start variable.

- We will take two variables ansStart and ansEnd initialized with -1. And when the sum crosses the maximum sum, we will set ansStart to the start variable and ansEnd to the current index i.e. i.

- The rest of the approach will be the same as Kadaneâ€™s Algorithm.
  
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n;
  vector <int> a(n);
  for (int i = 0; i < n; i++) cin >> a[i];
  int start = -1, ansStart = -1, ansEnd = -1, maxi = LLONG_MIN, sum = 0;
  for (int i = 0; i < n; i++) {
      if (sum == 0) start = i;
      sum += a[i];
      if (sum > maxi) {
          maxi = sum;
          ansStart = start;
          ansEnd = i;
      }
      if (sum < 0) {
          sum = 0;
      }
  }
  for (int i = ansStart; i <= ansEnd; i++) {
      cout << a[i] << i << " ";
  }
}
```
